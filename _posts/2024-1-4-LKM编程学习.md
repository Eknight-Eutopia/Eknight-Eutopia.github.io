---
layout:     post   				    # 使用的布局（不需要改）
title:      LKM编程 				# 标题 
subtitle:   Eutopia's Blog #副标题
date:       2024-1-4				# 时间
author:     Eutopia 						# 作者
header-img: img/post-bg-14.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 内核模块
---



# LKM编程

## Chapter 1. Introduction

### 1.1. What Is A Kernel Module?

**LKM：**用于扩展内核的功能，运行在内核态，为ELF二进制文件，如果不使用内核模块，会导致需要给内核添加功能时只能重新编译整个内核，不是很方便。

### 1.2. How Do Modules Get Into The Kernel?

使用`lsmod`命令查看已经加载到内核的模块（`/proc/modules`）。

使用`modprobe`命令加载指定模块到内核（自动查询模块的依赖关系进行加载`/lib/modules/version/kernel/*/*.ko`）

使用`insmod`命令加载模块到内核，不会查询依赖关系（`modprobe`调用该命令）

```shell
insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko
insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko


modprobe msdos
```

**华为路由器LKM列表**

```shell
root@debian-mips:~# lsmod
Module                  Size  Used by
msdos                   7642  0 
fat                    54395  1 msdos
ipv6                  312786  12 
loop                   13153  0 
mtdchar                 7769  0 
cfi_cmdset_0001        26278  1 
cfi_probe               3224  0 
gen_probe               2353  1 cfi_probe
sg                     30552  0 
uhci_hcd               26706  0 
cfi_util                4778  2 cfi_cmdset_0001,cfi_probe
ehci_hcd               49012  0 
physmap                 2637  0 
sr_mod                 16338  0 
i2c_piix4               5936  0 
mtd                    18073  6 mtdchar,cfi_cmdset_0001,physmap
8139too                20824  0 
psmouse                53122  0 
usbcore               152780  3 uhci_hcd,ehci_hcd
chipreg                 1474  2 cfi_probe,physmap
cdrom                  38519  1 sr_mod
i2c_core               18515  1 i2c_piix4
8139cp                 20460  0 
serio_raw               4416  0 
map_funcs               1034  1 physmap
evdev                   8808  0 
nls_base                6015  2 fat,usbcore
```



## Chapter2.Hello World

### 2.1. Hello, World (part 1): The Simplest Module

```c
/*  
 *  hello-1.c - The simplest kernel module.
 */
#include <linux/module.h>	/* Needed by all modules */
#include <linux/kernel.h>	/* Needed for KERN_INFO */

int init_module(void)
{
	printk(KERN_INFO "Hello world 1.\n");

	/* 
	 * A non 0 return means init_module failed; module can't be loaded. 
	 */
	return 0;
}

void cleanup_module(void)
{
	printk(KERN_INFO "Goodbye world 1.\n");
```

内核模块必须至少有两个函数:一个名为`init module()`的“开始”(初始化)函数，它在模块被`insmod`时被调用;一个名为`cleanup module()`的“结束”(清理)函数，它在模块被`rmmod`之前被调用。（在内核版本2.3后可以不这么命名）

注意：需要更换include路径

#### 模块的加载流程

- 驱动程序注册设备，创建系统信息（`/sys/class/xxx`）
- 注册设备使用的是模块文件名，要带.ko后缀
- 当操作已插入内核的模块时，只需使用模块名
- udev|mdev根据注册的设备信息，创建设备节点（`/dev/xxx`）
- 所有设备节点信息存储在`/proc/devices`
- 加载后会输出模块内的加载信息，通过`dmesg`查看

#### init_module系统调用流程

- 不依赖C库。链接/重定位自己完成
- Kernel/module.c/init_module
- 拷贝到内核：copy_module_from_user
- 地址空间分配：layout_and_allocate
- 符号解析：simplify_symbols
- 重定位:apply_relocations
- 执行：complete_formation

#### 内核驱动的两种执行方式



## Questions

1. 内核模块无法独立运行，这个限制是否就是因为内核库函数需要由内核提供？如果不是那应该是什么？
2. 
