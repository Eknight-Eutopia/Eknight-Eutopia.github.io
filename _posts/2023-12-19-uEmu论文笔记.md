# Automatic Firmware Emulation through Invalidity-guided Knowledge Inference  

## 摘要

设计了μEmu，使用动态符号执行的方式规避了P2IM需要人工参与基于Access-Pattern对MMIO进行分类的问题，但是存在了路径消失的问题。

## 解决问题

当前已有的对固件模拟方法有在硬件上进行模拟，完全脱离硬件模拟等方式，但都有其缺点。例如结合硬件会使fuzzing效率降低，模拟外设P2IM存在寄存器错分类。

uEmu采用动态符号执行技术对固件进行fuzz。

## 主要贡献

- 提出了固件的模拟执行会同时受到多个外设寄存器的影响。更加重视寄存器在执行时序上的依赖关系。（P2IM相较于此则是规定了固定的MMIO访问规则。实际上并不必须）
- 采用动态符号执行求解寄存器的依赖关系和满足条件解。
- 使用深度优先搜索进行动态执行，从而避免了路径爆炸的问题，不过也一定程度上造成了路径消失的问题。
- 提出了将寄存器约束求解存储到知识库的概念，知识库的树状结构。

## 尚存不足

存在路径消失

## 实现细节

分为两个阶段：知识提取阶段和动态分析阶段

使用了S2E平台与Qemu工具，具体结构如下

![Figure_2](/img/posts/2023-12-19-uEmu论文笔记/Figure_2.png)

### 知识提取阶段

通过挂钩固件对MMIO的写操作，将MMIO寄存器存入知识库（KB）。之后再根据符号化执行来增加MMIO的约束，根据约束求解MMIO特定值并且根据不同MMIO值进入不同分支，在此过程中需要保持固件运行状态为valid（有评价指标），如果MMIO进入分支是invalid，则更换MMIO值，切换到另一分支，在此过程中MMIO分配的值会以分层cache的形式存储在KB中。

#### 根据不同情况，将cache形式分为4类。

- T0：严格来说并不是一个匹配规则，而是对大部分外设寄存器存储建模，对MMIO进行写操作时，将对应的值存储到KB中，再之后需要读取时返回相应的值即可。如果导致程序进入invalid状态，则更新到T1。

- T1：不只记录值，而且记录其寄存器地址和PC（Program Counter）值加以区分。（由于大部分外设寄存器在特定PC处值是固定的），当进入到invalid状态时，更新到T2规则进行匹配

- T2：当寄存器地址与PC均相同时，需要T2进行区分，添加了对上下文参数（上三级调用函数PC值+函数参数）的哈希值。如下图`UART_WaitOnFlagUntilTimeout`函数，两个函数如果都用T1规则匹配，会返回相同值，但是会导致系统异常。因此需要T2规则，因为调用者的PC不同（line3，line7）.

  ![Listing_2](/img/posts/2023-12-19-uEmu论文笔记/Listing_2.png)

- T3：当上下文也相同时，将读取操作分为一个列表，按字符单位逐步读取（符号化执行也是使用了按字节分为多个符号）。如下图，若使用T2规则，由于上下文完全相同，导致返回给该函数的四个字节只能是“OOOO”，所以需要按照字节为单位生成四个符号。读取时逐步读取。

  ![image-20231205111046993](/img/posts/2023-12-19-uEmu论文笔记/image-20231205111046993.png)

#### invalid执行状态判断标准

- 死循环：如果寄存器包含符号变量，uEmu将其解为具体值并作比较，如果发现重复则证明是死循环。（检查范围为30个代码基本块，main函数）
- 长循环：固件在等待某种特定操作，导致超时。如果发现循环次数超过2000即认为为长循环
- **非法读写**：非法访问未装载内存，装载的内存包括（ROM，RAM，系统区域和外设区域）
- 用户定义：例如断言失败操作。

